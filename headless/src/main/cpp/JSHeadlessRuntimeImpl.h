#pragma once

#include <jshostheadless/JSHeadlessRuntime.h>

#include <ReactNativeHost/React.h>
#include <jsi/jsi.h>
#include <ExecutionContext/ExecutionContext.h>
#include "JSINative.g.h"

// We have two different implementations available of ReactNativeHost for headless (UI-less) Javascript computation
//
// Old RNHost support UI and is a thin wrapper around the open source RCTBridge.
// But, it is not easy to make the hosting multi-document friendly using the Old host. Hence we currently don't have support multidoc scenarios with Old host.
//
// New RNHost is more tailored for Office consumption, provides more hooks for power users and shares the same interface and most of implementation with Windows.
// But it currently lacks some key features such as the support for loading bundles from metro server.
//
// So, It is recommended to define this macro during development to enable loading from metro server.
// And undef it before checking in.
// #define USE_OLD_RNHOST

namespace Mso::JSHost::Headless {

struct JSHeadlessRuntime : public Mso::RefCountedObject<JSRuntime>
{
private:

    // This Jsi::HostObject is called from JS code to notify native when it is safe to call into JS methods throug JsiEnv generated interfaces. 
    // JSINative.g.h and JSINative.g.cpp are autogenerated using jsieng codegen from the following typescript signature,
    //
    // JSINative.ts
    //
    // // tslint:disable-next-line:no-unused-variable
    // declare const nativeNamespace = 'Mso.JSHost.Headless';
    //
    // declare namespace JsiNative {
    //     function initialize(): void;
    // }

    struct JsiNativeImpl : public JsiNative
    {
        JsiNativeImpl(facebook::jsi::Runtime &runtime, JSHeadlessRuntime &parent)
            : JsiNative(runtime), m_parent(parent)
        {
        }

        // This gets called from the JavaScript bundle, so we know it finished loading at this time
        void initialize() override
        {
            m_parent.OnJSLoaded(m_runtime);
        }

    private:
        JSHeadlessRuntime &m_parent;
    };


    Mso::React::ReactOptions CreateReactOptions();
    void CreateReactInstance();
    void EnsureSDXRegisteration();
    void Initialize(Mso::TCntPtr<Mso::ApplicationModel::IExecutionContext> executionContext =
                    Mso::ApplicationModel::GetCurrentExecutionContext());
    facebook::jsi::Runtime& GetJsiRuntime() const noexcept;

#ifdef USE_OLD_RNHOST
    Mso::TCntPtr<Mso::React::IReactInstance> m_spReactInstance {nullptr};
#else
    Mso::TCntPtr<Mso::React::IReactHost> m_spReactInstance {nullptr};
#endif

    std::shared_ptr<JsiNativeImpl> m_spJsiNativeImpl { nullptr };
    facebook::jsi::Runtime *m_runtime { nullptr };
    std::vector<std::function<void(facebook::jsi::Runtime& runtime)>> m_pendingFuncs;
    std::atomic<bool> m_initialized;
    JSRuntimeOptions m_options;

public:
    JSHeadlessRuntime(JSRuntimeOptions&& options);
    virtual ~JSHeadlessRuntime() override {}
    virtual void Post(std::function<void(facebook::jsi::Runtime& runtime)>&&callback) override;  

    // TODO: Avoid making these public.
    void OnJSLoaded(facebook::jsi::Runtime &runtime);
    facebook::react::RuntimeExecutor GetRuntimeExecutor();
    JSRuntimeOptions& Options() { return m_options; };
};

} // namespace Mso::JSHost
